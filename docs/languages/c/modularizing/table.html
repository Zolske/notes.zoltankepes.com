<table>
  <thead>
    <tr>
      <th colspan="2">String Length</th>
    </tr>
    <tr>
      <th>prototype</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <code>size_t&nbsp;strlen(const&nbsp;char&nbsp;*s);</code>
      </td>
      <td>
        The strlen() function calculates the length of the string pointed to by
        `s`, excluding the terminating null byte ('\0').</b><br />
        <b>return value</b><br />
        The strlen() function returns the number of bytes in the string pointed
        to by `s`.
      </td>
    </tr>
    <tr>
      <td>
        <code
          >size_t&nbsp;strnlen(const&nbsp;char&nbsp;s[.maxl],&nbsp;size_t&nbsp;maxl);</code
        >
      </td>
      <td>
        The str<b>n</b>len() function returns the number of bytes in the string
        pointed to by s, excluding the terminating null byte ('\0'), but at most
        maxl. In doing this, strnlen() looks only at the first maxl characters
        in the string pointed to by s and never beyond s[maxl-1].</b><br />
        <b>return value</b><br />
        The strnlen() function returns strlen(s), if that is less than maxl, or
        maxl if there is no null terminating ('\0') among the first maxl
        characters pointed to by s.
      </td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td>header</td>
      <td>
        <code>&lt;string.h&gt;</code>
      </td>
    </tr>
  </tfoot>
</table>

<table>
  <thead>
    <tr>
      <th>prototype</th>
      <th>explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>int isalnum(int c);</code></td>
      <td>checks for an alphanumeric character; it is equivalent to (isalpha(c) || isdigit(c)).
      </td>
    </tr>
    <tr>
      <td><code>int isalpha(int c);</code></td>
      <td>checks for an alphabetic character; in the standard "C" locale, it is equivalent to (isupper(c) || islower(c)). In some locales, there may be additional characters for which isalpha() is true-letters which are neither upper case nor lower case.</td>
    </tr>
    <tr>
      <td><code>int isascii(int c);</code></td>
      <td>checks whether c is a 7-bit unsigned char value that fits into the ASCII character set.</td>
    </tr>
    <tr>
      <td><code>int isblank(int c);</code></td>
      <td>checks for a blank character; that is, a space or a tab.</td>
    </tr>
    <tr>
      <td><code>int iscntrl(int c);</code></td>
      <td>checks for a control character.</td>
    </tr>
    <tr>
      <td><code>int isdigit(int c);</code></td>
      <td>checks for a digit (0 through 9).</td>
    </tr>
    <tr>
      <td><code>int isgraph(int c);</code></td>
      <td>hecks for any printable character except space.</td>
    </tr>
    <tr>
      <td><code>int islower(int c);</code></td>
      <td>checks for a lower-case character.</td>
    </tr>
    <tr>
      <td><code>int isprint(int c);</code></td>
      <td>checks for any printable character including space.</td>
    </tr>
    <tr>
      <td><code>int ispunct(int c);</code></td>
      <td>checks for any printable character which is not a space or an alphanumeric character.</td>
    </tr>
    <tr>
      <td><code>int isspace(int c);</code></td>
      <td>checks for white-space characters. In the "C" and "POSIX" locales, these are: space, form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').</td>
    </tr>
    <tr>
      <td><code>int isupper(int c);</code></td>
      <td>checks for an uppercase letter.</td>
    </tr>
    <tr>
      <td><code>int&nbsp;isxdigit(int&nbsp;c);</code></td>
      <td>checks for a hexadecimal digits, that is, one of<br />
        0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td colspan="2"><b>Return Value:</b><br />
        The values returned are nonzero if the character c falls into the tested class, and a zero value if not.
      </td>
    </tr>
    <tr>
      <td colspan="2"><b>Note:</b><br />
        The details of what characters belong into which class depend on the current locale. For example, isupper() will not recognize an A-umlaut (Ã„) as an uppercase letter in the default C locale.
      </td>
    </tr>
  </tfoot>
</table>

#######################################################################
<details>
  <summary>changing the case</summary>
  <table>
    <thead>
      <tr>
        <tr>
          <th>prototype</th>
          <th>description</th>
        </tr>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>int tolower(int argument);</code></td>
        <td>If the arguments passed to the tolower() function are other than an uppercase alphabet, it returns the same character passed to the function otherwise it returns a lowercase character.</td>
      </tr>
      <tr>
        <td><code>int toupper(int argument);</code></td>
        <td>If the arguments passed to the toupper() function are other than a lowercase alphabet, it returns the same character passed to the function otherwise it returns an uppercase character.</td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b>Header:</b><br />
          &lt;ctype.h&gt;
        </td>
      </tr>
    </tfoot>
  </table>
</details>

##################################################################################
<details>
  <summary>check string length</summary>
  <table>
    <thead>
      <tr>
          <th>prototype</th>
          <th>description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>size_t strlen(const char *s);</code></td>
        <td>The strlen() function calculates the length of the string pointed to by `s`, excluding the terminating null byte ('\0').
          <br /><b>Return Value:</b><br />
          The strlen() function returns the number of bytes in the string pointed to by `s`.
          <br /><b>Note:</b><br />
          In cases where the input buffer may not contain a terminating null byte, strnlen(3) should be used instead.
        </td>
      </tr>
      <tr>
        <td><code>size_t&nbsp;strnlen(const&nbsp;char&nbsp;s[.maxl],&nbsp;size_t&nbsp;maxl);</code></td>
        <td>The strnlen() function returns the number of bytes in the string pointed to by s, excluding the terminating null byte ('\0'), but at most maxl. In doing this, strnlen() looks only at the first maxl characters in the string pointed to by s and never beyond s[maxl-1].
          <br /><b>Return Value:</b><br />
          The strnlen() function returns strlen(s), if that is less than maxl, or maxl if there is no null terminating ('\0') among the first maxl characters pointed to by s.
        </td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b>Header:</b><br />
          &lt;string.h&gt;</td>
      </tr>
    </tfoot>
  </table>
</details>
##################################################################################
<details>
  <summary>copy string</summary>
  <table>
    <thead>
      <tr>
          <th>prototype</th>
          <th>description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>char&nbsp;*strcpy(char&nbsp;*dest,&nbsp;const&nbsp;char&nbsp;*src);</code></td>
        <td>
          The strcpy() function copies the string pointed to by src, including the terminating null byte ('\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns!
          When the beginning of the destination string crosses the ending of the source string.
          <br /><b>Return Value:</b><br />
          Returns a pointer to the destination string dest.
        </td>
      </tr>
      <tr>
        <td><code>char&nbsp;*strncpy(char&nbsp;*dest,&nbsp;const&nbsp;char&nbsp;*src,&nbsp;size_t&nbsp;n);</code></td>
        <td>
          The strncpy() function is similar, except that at most n bytes of src are copied.  
          If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated.
          If the length of src is less than n, strncpy() writes additional null bytes to dest to ensure that a total of n bytes are written.
          <br /><b>Return Value:</b><br />
          Returns a pointer to the destination string dest.
        </td>
      </tr>
      <tr>
        <td><code>size_t&nbsp;strlcpy(char&nbsp;*dst,&nbsp;const&nbsp;char&nbsp;*src,&nbsp;size_t&nbsp;size);</code></td>
        <td>
          Copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result.
          <br /><b>Return Value:</b><br />
          The length of src.
        </td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b></b><br />
        </td>
      </tr>
    </tfoot>
  </table>
</details>
##################################################################################
<details>
  <summary>adding strings together</summary>
  <table>
    <thead>
        <tr>
          <th>prototype</th>
          <th>description</th>
        </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>char&nbsp;*strncat(char&nbsp;*dest,&nbsp;const&nbsp;char&nbsp;*src,&nbsp;size_t&nbsp;n);</code></td>
        <td>
          Appends the string pointed to by src to the end of the string pointed to by dest up to n characters long. Only Null-terminated if there was one in src within the range of src.
          <br /><b>Return Value:</b><br />
          A pointer to the destination string dest.
        </td>
      </tr>
      <tr>
        <td><code>size_t&nbsp;strlcat(char&nbsp;*dst,&nbsp;const&nbsp;char&nbsp;*src,&nbsp;size_t&nbsp;size);</code></td>
        <td>
          Appends the NUL-terminated string `src` to the end of `dst`. It will append at most `size - strlen(dst) - 1` bytes, NUL-terminating the result.
          <br /><b>Return Value:</b><br />
          The initial length of dst plus the length of src.
        </td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b>Header:</b><br />
          &lt;string.h&gt;</td>
      </tr>
    </tfoot>
  </table>
</details>

##################################################################################
<details>
  <summary>find character or string in string</summary>
  <table>
    <thead>
        <tr>
          <th>prototype</th>
          <th>description</th>
        </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>char&nbsp;*strchr(const&nbsp;char&nbsp;*str,&nbsp;int&nbsp;c)</code></td>
        <td>
          Searches for the first occurrence of the character c (an unsigned char) in the string pointed to by the argument str.
          <br /><b>Return Value:</b><br />
          Returns a pointer to the first occurrence of the character c in the string str, or NULL if the character is not found.       
        </td>
      </tr>
      <tr>
        <td><code>char *strrchr(const&nbsp;char&nbsp;*str,&nbsp;int&nbsp;c)</code></td>
        <td>
          Searches for the last occurrence of the character c (an unsigned char) in the string pointed to, by the argument str.
          <br /><b>Return Value:</b><br />
          Returns a pointer to the last occurrence of the character c in the string str, or NULL if the character is not found.     
        </td>
      </tr>
      <tr>
        <td><code>char&nbsp;*strstr(const&nbsp;char&nbsp;*haystack,&nbsp;const&nbsp;char&nbsp;*needle)</code></td>
        <td>
          Finds the first occurrence of the substring needle in the string haystack. The terminating '\0' characters are not compared.
          - haystack - This is the main C string to be scanned.
          - needle - This is the small string to be searched within haystack string.
          <br /><b>Return Value:</b><br />
          This function returns a pointer to the first occurrence in haystack of any of the entire sequence of characters specified in needle, or a Null pointer if the sequence is not present in haystack.
        </td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b>Header:</b><br />
          <code>&lt;string.h&gt;</code>
        </td>
      </tr>
    </tfoot>
  </table>
</details>
##################################################################################
<details>
  <summary>comparing strings</summary>
  <table>
    <thead>
        <tr>
          <th>prototype</th>
          <th>description</th>
        </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>int&nbsp;strcmp(const&nbsp;char&nbsp;*str1,&nbsp;const&nbsp;char&nbsp;*str2)</code></td>
        <td>Compares the string pointed to, by str1 to the string pointed to by str2.</td>
      </tr>
      <tr>
        <td><code>int&nbsp;strncmp(const&nbsp;char&nbsp;*str1,&nbsp;const&nbsp;char&nbsp;*str2,&nbsp;size_t&nbsp;n)</code></td>
        <td>Compares at most the first n bytes of str1 and str2.</td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b>Return Value:</b><br />
          <br />- if Return value &lt; 0 then it indicates str1 is less than str2.
          <br />- if Return value &gt; 0 then it indicates str2 is less than str1.
          <br />- if Return value = 0 then it indicates str1 is equal to str2.
        </td>
      </tr>
      <tr>
        <td colspan="2"><b>Header:</b><br />
          <code>&lt;string.h&gt;</code>
        </td>
      </tr>
    </tfoot>
  </table>
</details>
##################################################################################
<details>
  <summary>changing the case</summary>
  <table>
    <thead>
        <tr>
          <th>prototype</th>
          <th>description</th>
        </tr>
    </thead>
    <tbody>
      <tr>
        <td><code></code></td>
        <td></td>
      </tr>
      <tr>
        <td><code></code></td>
        <td></td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <td colspan="2"><b></b><br />
          <code></code>
        </td>
      </tr>
    </tfoot>
  </table>
</details>
#### isalnum() `int isalnum(int c);` `<ctype.h>`

  checks for an alphanumeric character; it is equivalent to (isalpha(c) || isdigit(c)).
  
  #### isalpha() `int isalpha(int c);` `<ctype.h>`
  
  checks for an alphabetic character; in the standard "C" locale, it is equivalent to (isupper(c) || islower(c)). In some locales, there may be additional characters for which isalpha() is true-letters which are neither upper case nor lower case.
  
  #### isascii() `int isascii(int c);` `<ctype.h>`
  
  checks whether c is a 7-bit unsigned char value that fits into the ASCII character set.
  
  #### isblank() `int isblank(int c);` `<ctype.h>`
  
  checks for a blank character; that is, a space or a tab.
  
  #### iscntrl() `int iscntrl(int c);` `<ctype.h>`
  
  checks for a control character.
  
  #### isdigit() `int isdigit(int c);` `<ctype.h>`
  
  checks for a digit (0 through 9).
  
  #### isgraph() `int isgraph(int c);` `<ctype.h>`
  
  checks for any printable character except space.
  
  #### islower() `int islower(int c);` `<ctype.h>`
  
  checks for a lower-case character.
  
  #### isprint() `int isprint(int c);` `<ctype.h>`
  
  checks for any printable character including space.
  
  #### ispunct() `int ispunct(int c);` `<ctype.h>`
  
  checks for any printable character which is not a space or an alphanumeric character.
  
  #### isspace() `int isspace(int c);` `<ctype.h>`
  
  checks for white-space characters. In the "C" and "POSIX" locales, these are: space, form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
  
  #### isupper() `int isupper(int c);` `<ctype.h>`
  
  checks for an uppercase letter.
  
  #### isxdigit() `int isxdigit(int c);` `<ctype.h>`
  
  checks for a hexadecimal digits, that is, one of
  0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.
  
  ### Return Value
  
  The values returned are nonzero if the character c falls into the tested class, and a zero value if not.
  
  ### Note
  
  The details of what characters belong into which class depend on the current locale. For example, isupper() will not recognize an A-umlaut (Ã„) as an uppercase letter in the default C locale.
  
  ---

  #### tolower `int tolower(int argument);` `ctype.h`

If the arguments passed to the tolower() function are other than an uppercase alphabet, it returns the same character passed to the function otherwise it returns a lowercase character.

#### toupper `int toupper(int argument);` `ctype.h`

If the arguments passed to the toupper() function are other than a lowercase alphabet, it returns the same character passed to the function otherwise it returns an uppercase character.

##################################################################################################################################
#### strlen `size_t strlen(const char *s);` `<string.h>`

  The strlen() function calculates the length of the string pointed to by `s`, excluding the terminating null byte ('\0').
  
  ##### RETURN VALUE
  
  The strlen() function returns the number of bytes in the string pointed to by `s`.
  
  ##### NOTES
  
  In cases where the input buffer may not contain a terminating null byte, strnlen(3) should be used instead.
  
  #### strnlen `size_t strnlen(const char s[.maxlen], size_t maxlen);` `<string.h>`
  
  The strnlen() function returns the number of bytes in the string pointed to by s, excluding the terminating null byte ('\0'), but at most maxlen. In doing this, strnlen() looks only at the first maxlen characters in the string pointed to by s and never beyond s[maxlen-1].
  
  ##### RETURN VALUE
  
  The strnlen() function returns strlen(s), if that is less than maxlen, or maxlen if there is no null terminating ('\0') among the first maxlen characters pointed to by s.
  
  ---

  ###################################################################################### strcpy `char *strcpy(char *dest, const char *src);` `<string.h>`

    The strcpy() function copies the string pointed to by src, including the terminating null byte ('\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy. Beware of buffer overruns!
    :::info string overlapping
    When the beginning of the destination string crosses the ending of the source string.
    :::
    
    #### strncpy `char *strncpy(char *dest, const char *src, size_t n);` `<string.h>`
    
    The strncpy() function is similar, except that at most n bytes of src are copied.  
    :::danger
    If there is no null byte among the first n bytes of src, the string placed in dest will not be null-terminated.
    :::
    If the length of src is less than n, strncpy() writes additional null bytes to dest to ensure that a total of n bytes are written.
    
    ##### RETURN VALUE
    
    The strcpy(), and strncpy() functions return a pointer to the destination string dest.
    
    #### strlcpy `size_t strlcpy(char *dst, const char *src, size_t size);` `<string.h>`
    
    Copies up to `size - 1` characters from the NUL-terminated string `src` to `dst`, NUL-terminating the result.
    
    ##### RETURN VALUE
    
    The length of src.
    
    ###### summary:
    
    | function    | Null termination                                                                       | return                   |
    | ----------- | -------------------------------------------------------------------------------------- | ------------------------ |
    | strcpy      | yes, copy Null from source                                                             | pointer to `dest` string |
    | str**n**cpy | if Null is within the range of `n` or the remaining spaces if `n` is longer than `src` | pointer to `dest` string |
    | str**l**cpy | yes                                                                                    | length of `src`          |
    
    ##################################################################################################################################
    #### strncat `char *strncat(char *dest, const char *src, size_t n);`

Appends the string pointed to by src to the end of the string pointed to by dest up to n characters long. Only Null-terminated if there was one in src within the range of src.

##### RETURN VALUE

A pointer to the destination string dest.

#### strlcat `size_t strlcat(char *dst, const char *src, size_t size);` `<string.h>`

Appends the NUL-terminated string `src` to the end of `dst`. It will append at most `size - strlen(dst) - 1` bytes, NUL-terminating the result.

##### RETURN VALUE

The initial length of dst plus the length of src.

##################################################################################################################################
#### strchr `char *strchr(const char *str, int c)`

Searches for the first occurrence of the character c (an unsigned char) in the string pointed to by the argument str.

##### RETURN VALUE

Returns a pointer to the **first** occurrence of the character c in the string str, or NULL if the character is not found.

#### strrchr `char *strrchr(const char *str, int c)`

Searches for the last occurrence of the character c (an unsigned char) in the string pointed to, by the argument str.

##### RETURN VALUE

Returns a pointer to the **last** occurrence of the character c in the string str, or NULL if the character is not found.

#### strstr `char *strstr(const char *haystack, const char *needle)`

Finds the first occurrence of the substring needle in the string haystack. The terminating '\0' characters are not compared.

- haystack − This is the main C string to be scanned.
- needle − This is the small string to be searched within haystack string.

##### RETURN VALUE

This function returns a pointer to the first occurrence in haystack of any of the entire sequence of characters specified in needle, or a Null pointer if the sequence is not present in haystack.

##################################################################################################################################
#### strcmp `int strcmp(const char *str1, const char *str2)`

Compares the string pointed to, by str1 to the string pointed to by str2.

#### strncmp `int strncmp(const char *str1, const char *str2, size_t n)`

Compares at most the first n bytes of str1 and str2.

##### RETURN VALUE for strcmp and strncmp

- if Return value < 0 then it indicates str1 is less than str2.
- if Return value > 0 then it indicates str2 is less than str1.
- if Return value = 0 then it indicates str1 is equal to str2.
